# DataBus
Instructions in English [below](#english-version).

Шина обеспечивает взаимодействие клиента (отправителя) и сервера (приёмника) HTTP-запросов. Предназначена в качестве буфера обмена HTTP-запросами (сообщениями). Также имеет интерфейс для взаимодействия с [Redis](https://redis.io/) извне.

<img src=".\images\001.png" alt="001" style="zoom: 50%;" />

Внутри шина устроена примерно так. На схеме показано только движение HTTP-запросов (не весь функционал).

<img src=".\images\002.png" alt="002" style="zoom: 80%;" />

Клиент посылает [специально подготовленный запрос](##подготовка-запроса) (input request) в шину. Соответствующий эндпойнт FastAPI обрабатывает поступивший запрос, конвертирует его в сообщение (message request) и сохраняет его в очереди Redis. 

Независимый процесс последовательно достаёт сообщения из очереди, строит из них запросы (output request) и рассылает получателям в соответствии с мепингом. От получателей приходит ответ (response). Ответ преобразуется в сообщение (message response) и сохраняется в отдельной очереди Redis, если это указано в мепинге. Если запрос по каким-либо причинам не был доставлен хотя бы одному получателю, он помещается в самое начало очереди. Каждый из получателей, указанный в мепинге, гарантировано получает данный запрос только один раз независимо от других.

Далее независимый процесс последовательно достаёт сообщения (message response) из очереди, строит из них запросы (async response) и доставляет их исходному клиенту (отправителю исходного запроса = input request) или прочему получателю, который указывается в мепинге. Также, если запрос не был доставлен, он помещается в начало очереди.

Так происходит весь процесс обмена сообщениями (запрос-ответ).

   

## Преимущества

Универсальная шина передачи данных решает такие проблемы как:

1. Изменение IP-адреса сервера. Новый адрес сервера прописывается при этом в мепинге. Достаточно сделать запрос к соответствующему эндпойнту (*PUT /api/map/{item_id}*).
2. Периодическое отключение или нестабильная работа сервера. В этом случае запросы будут накапливаться в очереди шины и будут гарантированно доставлены позже. Клиенту не нужно ждать и повторять отправку запроса.
3. Сложная маршрутизация запросов. Запрос может быть разделён на несколько приёмников. Разные запросы могут быть перенаправлены на разные сервера. Маршруты задаются через мепинг (*POST /api/map/new*).
4. Сложная аутентификация сервера. Некоторые клиенты (например, 1С:Предприятие) не поддерживают JWT-аутентификацию, поэтому шина выступает как шлюз для аутентификации. Требуется доработка функционала.
5. Асинхронное взаимодействие: ответ сервера (приёмника) обрабатывается отдельно и пересылается клиенту (отправителю).

   

## Пример использования

У нас есть небольшая фирма. Она занимается обработкой заявок на партнёрские продукты и доставкой этих товаров потребителю. Для нас важна быстрота реакции на запросы клиентов. Поэтому у нас чётко выстроенные бизнес-процессы.

Мы хотим напрямую отслеживать заказы, созданные через мобильный клиент (мобильное приложение) так, чтобы они мгновенно появлялись в нашей CRM-системе. При этом сама CRM-система находится на ноутбуках наших сотрудников, данные периодически синхронизируются с облаком (раз в 5 минут или по требованию). Ноутбуки сотрудников подключены к сети только в рабочее время. Заявки на заказы, соответственно, могут быть оставлены пользователями когда угодно, а обрабатываются только в рабочие часы нашими сотрудниками. 

Как работало раньше?

1. В мобильном приложении клиент оформляет новую заявку. Все данные заносятся в [Firestore Database](https://firebase.google.com/).
2. Облачный сервер периодически проверяет данные на изменение в мобильной базе. Т.к. важна реакция, время периодической проверки пришлось сократить до 10 секунд (как на стороне сервера, так и на стороне CRM-клиента). В худшем случае на CRM-клиент заявка может прийти через 20 секунд. 
3. CRM-клиенты проверяют облачный сервер на изменения в данных с периодичностью 10 секунд. Общий поток запросов на чтение составляет: 12 сотрудников x 6 запросов в минуту x 60 минут x 24 часа = 103680 запросов в день. В связи с этим нагрузка на облачную базу начинает увеличиваться и будет только расти. Также за такое количество запросов приходится переплачивать.
4. Действия, которые привязаны к обновлению данных в CRM системе (на клиентах и на облачном сервере), также отрабатывают с указанной выше задержкой.
5. Таким образом заявки гарантировано будут доставлены, но с указанным временным лагом. Система будет функционировать  приемлемо в большинстве случаев, но с некоторыми издержками. С увеличением штата сотрудников затраты вырастают, возникает проблема масштабирования.

Как работает новая система? 

1. Шина передачи данных устанавливается на облачном сервере и всегда доступна извне.
2. CRM система (клиент) в начале работы сотрудника проверяет актуальность своего IP-адреса и при необходимости посылает запрос в шину на его корректировку, т.к. динамический IP адрес может изменяться.
3. Все заявки, которые накопились в нерабочее время (за ночь), приходят в CRM скопом.
4. В мобильном приложении клиент оформляет новую заявку, нажимает кнопку, отсылается запрос к шине по API.
5. Шина обрабатывает запрос и пересылает его CRM системе. Можно организовать пересылку напрямую CRM-клиентам. Если связь нестабильна, сообщение гарантировано придёт немного позже.
6. CRM система получает запрос, обрабатывает его и оповещает сотрудника о поступившей заявке на заказ. Также CRM может выборочно обновить данные из облака, т.к. получение запроса может являться триггером и на другие действия. 
7. Таким образом сотрудник сможет молниеносно отреагировать на заявку от клиента и обработать её быстро.

   

## СУБД

Шина может использовать для хранения данных любую СУБД, которая поддерживается [ORM Peewee](http://docs.peewee-orm.com/en/latest/). В этом репозитории используется СУБД SQLite. Вы можете легко подключить такие СУБД как: MySQL, PostgreSQL и Cockroach.

Для хранения внешних данных и в качестве очереди шина использует [Redis](https://redis.io/). Redis использует стандартные настройки подключения: redis://localhost:6379/0.

   

## Установка

Последовательность действий для установки:

- Установите и настройте [Redis](https://redis.io/docs/getting-started/installation/)

- Для создания виртуальной среды могут использоваться *conda* или *virtualenv*

- Создайте виртуальное окружение `conda create -n venv`

- Активируйте виртуальное окружение `conda activate venv`

- Установите пакеты `pip install -r requirements.txt`

- Перейдите в папку с проектом

- Создайте новую базу данных \<database\>

- Выполните миграцию `python pw_migrate.py migrate --database=postgresql://postgres@<host_postgres>:5432/<database>`

  \<host_postgres\> - рабочий хост базы данных

  \<database\> - имя базы данных

- Добавьте пользователя с административной ролью

- Настройте конфигурационный файл *conf.yaml*

- Запустите API `uvicorn main:app --reload`

- Через API заполните необходимые таблицы БД

   

## Отладка

Запустите на отладку файл `main.py`

Запустите `receiver.py` в качестве приёмника запросов и `sender.py` как источник запросов.

`python receiver.py --detail false --server 127.0.0.1`
`python sender.py --detail false --server 127.0.0.1 --user admin --pass password --send all`

Проверьте API на локальной машине: http://127.0.0.1:8000/

Доступ к REST API Swagger: http://127.0.0.1:8000/docs#/

Доступ к REST API Redoc: http://127.0.0.1:8000/redoc

   

## Конфигурация

Настройте конфигурационный файл *conf.yaml*.

Управление авторизацией через JWT токен:

- SECRET_KEY - Секретный ключ.

- ALGORITHM - Алгоритм. Чаще используется HS256.

- ACCESS_TOKEN_EXPIRE_MINUTES - Истечение токена через определённое время (в минутах).

Шина:

- DB.DOMAIN - Текущий домен (адрес), на который приходят запросы.

- DB.PORT - Выделенный порт. Не забудьте настроить разрешения для этого порта в своём брандмауэре.

Управление данными:

- DB.NAME - Расположение БД.

- DB.USER - Пользователь БД.

- DB.ASYNC - Асинхронное взаимодействие с БД (если значение *True*).

- DB.REQUEST_HISTORY - Сохранение истории запросов в БД.

   


## API

|      Group       |                   Type                    |        Endpoint        | Description                                                  |
| :--------------: | :---------------------------------------: | :--------------------: | ------------------------------------------------------------ |
|       user       |                   POST                    |         /login         | Получение текущего токена по кредам.                         |
|       user       |                   POST                    |        /signup         | Создание нового пользователя.                                |
|       user       |                    GET                    |       /api/user        | Сведения о текущем пользователе.                             |
|    HTTPMapApp    |                    GET                    |     /api/map/list      | Маппинг запросов. Список всех элементов.                     |
|    HTTPMapApp    |                    GET                    |    /api/map/update     | Маппинг запросов. Обновление глобальных переменных в самой шине. |
|    HTTPMapApp    |                    GET                    |   /api/map/{item_id}   | Маппинг запросов. Один элемент.                              |
|    HTTPMapApp    |                    PUT                    |   /api/map/{item_id}   | Маппинг запросов. Обновление полей элемента.                 |
|    HTTPMapApp    |                   POST                    |      /api/map/new      | Маппинг запросов. Новый элемент.                             |
|     RedisApp     |      GET<br/>PUT<br/>POST<br/>DELETE      |    /api/redis/{cmd}    | Выполнение запроса в Redis. <br/>*{cmd}* - Команда Redis. Список команд [здесь](https://redis.io/commands/).<br/>*args* - Параметры команды через пробел.<br/>Прочие параметры, определённые через *\<key\>=\<value\>*. |
|     QueueApp     | GET<br/>PUT<br/>POST<br/>PATCH<br/>DELETE |   /api/queue/{name}    | Отправка запроса в очередь шины.<br/>*{name}* - Название очереди. Очередь определяет (через маппинг) куда далее пойдёт запрос. |
| CommonHeadersApp |                    GET                    |   /api/headers/list    | Общие заголовки. Список всех элементов.                      |
| CommonHeadersApp |                    GET                    |  /api/headers/update   | Общие заголовки. Обновление глобальных переменных в самой шине. |
| CommonHeadersApp |                    GET                    | /api/headers/{item_id} | Общие заголовки. Один элемент.                               |
| CommonHeadersApp |                    PUT                    | /api/headers/{item_id} | Общие заголовки. Обновление полей элемента.                  |
| CommonHeadersApp |                   POST                    |    /api/headers/new    | Общие заголовки. Новый элемент.                              |
|  AdditionalApp   |                    GET                    |    /api/common/hash    | Хеш для пароля.                                              |
|  AdditionalApp   |                    GET                    |   /api/common/sha256   | SHA256 для текстовых данных (параметр *data*).               |
|  AdditionalApp   |                   POST                    |   /api/common/sha256   | SHA256 для файла (*file*).                                   |
|  AdditionalApp   |                    GET                    | /api/common/timestamp  | Дата и время в определённом формате.<br/>*sformat* - Заданный формат, *default value*: %Y-%m-%d %H:%M:%S |
|  AdditionalApp   |                    GET                    |    /api/common/now     | Текущие дата и время.                                        |
|  AdditionalApp   |                    GET                    |    /api/common/uuid    | Возвращает случайный UUID.                                   |
|  AdditionalApp   |                    GET                    |   /api/common/srand    | Возвращает случайную строку.<br/>*size* - размер строки<br/>*chars* - типы символов для выборки |
|                  |                                           |                        |                                                              |

   

## Подготовка запроса

Чтобы отправить запрос в шину, его необходимо подготовить. Предположим, есть исходный HTTP-запрос для получателя.

1. Изменяем URL на ***/api/queue/{name}*** . *{name}* очереди определяем в соответствии с маппингом.
2. Названия переменных, которые будут использоваться в шаблоне URL запроса, выносим в отдельный параметр-список ***params***.
3. URL-переменные также задаём как отдельные параметры в виде ***\<key\>=\<value\>***.
4. Для авторизации используем заголовок ***Authorization***.
5. Всё остальное оставляем без изменений.

   

## Производительность

Проводились замеры производительности HTTP-запросов напрямую (клиент - сервер) и с шиной. Если использовать хранение истории запросов (параметр *REQUEST_HISTORY*), то скорость шины падает примерно в 4.7 раза. Результаты замеров представлены в таблице ниже в секундах.

| Requests | Directly (First) | Bus + History | Directly (Second) | Bus         |
| -------- | ---------------- | ------------- | ----------------- | ----------- |
| 100      | 7.479515913      | 22.38414639   | 5.861896894       | 4.703070805 |
| 100      | 3.209643742      | 21.44252342   | 4.956573356       | 4.263683129 |
| 100      | 3.249170097      | 22.14673435   | 3.713075762       | 3.458604061 |
| Mean     | 4.646109917      | 21.99113472   | 4.843848671       | 4.141785999 |
|          |                  |               |                   |             |

   

   

# English version
